/*
 * Giant Swarm legacy API
 *
 * Caution: This is an incomplete description of some legacy API functions.
 *
 * API version: legacy
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package gsclientgen

import (
	"encoding/json"
	"fmt"
	"golang.org/x/net/context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type DefaultApiService service

/* DefaultApiService Create cluster
This operation is used to create a new Kubernetes cluster for an organization. The desired configuration can be specified using the __cluster definition format__ (see [external documentation](https://github.com/giantswarm/api-spec/blob/ master/details/CLUSTER_DEFINITION.md) for details). The cluster definition format allows to set a number of optional configuration details, like memory size and number of CPU cores. However, one attribute is __mandatory__ upon creation: The &#x60;owner&#x60; attribute must carry the name of the organization the cluster will belong to. Note that the acting user must be a member of that organization in order to create a cluster. It is *recommended* to also specify the &#x60;name&#x60; attribute to give the cluster a friendly name, like e. g. \&quot;Development Cluster\&quot;. Additional definition attributes can be used. Where attributes are ommitted, default configuration values will be applied. For example, if no &#x60;kubernetes_version&#x60; is specified, the latest version tested and provided by Giant Swarm is used. The &#x60;workers&#x60; attribute, if present, must contain an array of node definition objects. The number of objects given determines the number of workers created. For example, requesting three worker nodes with default configuration can be achieved by submitting an array of three empty objects: &#x60;&#x60;&#x60;\&quot;workers\&quot;: [{}, {}, {}]&#x60;&#x60;&#x60;
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param body New cluster definition
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return V4GenericResponse*/
func (a *DefaultApiService) AddCluster(ctx context.Context, authorization string, body V4AddClusterRequest, localVarOptionals map[string]interface{}) (V4GenericResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     V4GenericResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Add key-pair for cluster
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param clusterId ID of the cluster to create the key-pair for
@param body Description and expiry time for the new key-pair
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return V4AddKeyPairResponse*/
func (a *DefaultApiService) AddKeyPair(ctx context.Context, authorization string, clusterId string, body V4AddKeyPairBody, localVarOptionals map[string]interface{}) (V4AddKeyPairResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     V4AddKeyPairResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/clusters/{cluster_id}/key-pairs/"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", fmt.Sprintf("%v", clusterId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Delete cluster
This operation allows to delete a cluster.  __Caution:__ Deleting a cluster causes the termination of all workloads running on the cluster. Data stored on the worker nodes will be lost. There is no way to undo this operation.  The response is sent as soon as the request is validated. At that point, workloads might still be running on the cluster and may be accessible for a little wile, until the cluster is actually deleted.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param clusterId Cluster ID
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return V4GenericResponse*/
func (a *DefaultApiService) DeleteCluster(ctx context.Context, authorization string, clusterId string, localVarOptionals map[string]interface{}) (V4GenericResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     V4GenericResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/clusters/{cluster_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", fmt.Sprintf("%v", clusterId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Get cluster details
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param clusterId Cluster ID
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return V4ClusterDetailsModel*/
func (a *DefaultApiService) GetCluster(ctx context.Context, authorization string, clusterId string, localVarOptionals map[string]interface{}) (V4ClusterDetailsModel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     V4ClusterDetailsModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/clusters/{cluster_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", fmt.Sprintf("%v", clusterId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Get clusters
This operation fetches a list of clusters. The result depends on the permissions of the user. A normal user will get all the clusters the user has access to, via organization membership.  A user with admin permission will receive a list of all existing clusters.  The result array items are sparse representations of the cluster objects.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return []V4ClusterListItem*/
func (a *DefaultApiService) GetClusters(ctx context.Context, authorization string, localVarOptionals map[string]interface{}) ([]V4ClusterListItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []V4ClusterListItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Get information on the installation
See https://docs.giantswarm.io/api/#operation/getInfo
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return V4InfoResponse*/
func (a *DefaultApiService) GetInfo(ctx context.Context, authorization string, localVarOptionals map[string]interface{}) (V4InfoResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     V4InfoResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/info/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Get key-pairs for cluster
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param clusterId
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return []KeyPairModel*/
func (a *DefaultApiService) GetKeyPairs(ctx context.Context, authorization string, clusterId string, localVarOptionals map[string]interface{}) ([]KeyPairModel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []KeyPairModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/clusters/{cluster_id}/key-pairs/"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", fmt.Sprintf("%v", clusterId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Get releases
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return []V4ReleaseListItem*/
func (a *DefaultApiService) GetReleases(ctx context.Context, authorization string, localVarOptionals map[string]interface{}) ([]V4ReleaseListItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []V4ReleaseListItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/releases/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Get organizations for user
This operation allows to fetch a list of organizations the user is a member of. In the case of an admin user, the result includes all existing organizations.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return []V4OrganizationListItem*/
func (a *DefaultApiService) GetUserOrganizations(ctx context.Context, authorization string, localVarOptionals map[string]interface{}) ([]V4OrganizationListItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     []V4OrganizationListItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/organizations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Modify cluster
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param clusterId Cluster ID
@param body Modified cluster definition (JSON merge-patch)
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return V4ClusterDetailsModel*/
func (a *DefaultApiService) ModifyCluster(ctx context.Context, authorization string, clusterId string, body V4ModifyClusterRequest, localVarOptionals map[string]interface{}) (V4ClusterDetailsModel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     V4ClusterDetailsModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v4/clusters/{cluster_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_id"+"}", fmt.Sprintf("%v", clusterId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Log in as a user
This method takes email and password of a user and returns a new session token. The token can be found in the &#x60;data.Id&#x60; field of the response object.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param email User email address
@param payload base64 encoded password
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return LoginResponseModel*/
func (a *DefaultApiService) UserLogin(ctx context.Context, email string, payload LoginBodyModel, localVarOptionals map[string]interface{}) (LoginResponseModel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     LoginResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/user/{email}/login"
	localVarPath = strings.Replace(localVarPath, "{"+"email"+"}", fmt.Sprintf("%v", email), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	// body params
	localVarPostBody = &payload
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* DefaultApiService Expire the currently used auth token
* @param ctx context.Context for authentication, logging, tracing, etc.
@param authorization Header to pass an authorization token. The value has to be in the form &#x60;giantswarm &lt;token&gt;&#x60;.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "xRequestID" (string) A randomly generated key that can be used to track a request throughout services of Giant Swarm
    @param "xGiantSwarmActivity" (string) Name of an activity to track, like \&quot;list-clusters\&quot;
    @param "xGiantSwarmCmdLine" (string) If activity has been issued by a CLI, this header can contain the command line
@return GenericResponseModel*/
func (a *DefaultApiService) UserLogout(ctx context.Context, authorization string, localVarOptionals map[string]interface{}) (GenericResponseModel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     GenericResponseModel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/token/logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["xRequestID"], "string", "xRequestID"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmActivity"], "string", "xGiantSwarmActivity"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["xGiantSwarmCmdLine"], "string", "xGiantSwarmCmdLine"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		"text/plain",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(authorization, "")
	if localVarTempParam, localVarOk := localVarOptionals["xRequestID"].(string); localVarOk {
		localVarHeaderParams["X-Request-ID"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmActivity"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-Activity"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["xGiantSwarmCmdLine"].(string); localVarOk {
		localVarHeaderParams["X-Giant-Swarm-CmdLine"] = parameterToString(localVarTempParam, "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}
