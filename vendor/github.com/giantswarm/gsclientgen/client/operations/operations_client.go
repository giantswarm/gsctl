// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddCluster creates cluster

This operation is used to create a new Kubernetes cluster for an organization. The desired configuration can be specified using the __cluster definition format__ (see [external documentation](https://github.com/giantswarm/api-spec/blob/ master/details/CLUSTER_DEFINITION.md) for details).
The cluster definition format allows to set a number of optional configuration details, like memory size and number of CPU cores. However, one attribute is __mandatory__ upon creation: The `owner` attribute must carry the name of the organization the cluster will belong to. Note that the acting user must be a member of that organization in order to create a cluster.
It is *recommended* to also specify the `name` attribute to give the cluster a friendly name, like e. g. "Development Cluster".
Additional definition attributes can be used. Where attributes are ommitted, default configuration values will be applied. For example, if no `kubernetes_version` is specified, the latest version tested and provided by Giant Swarm is used.
The `workers` attribute, if present, must contain an array of node definition objects. The number of objects given determines the number of workers created. For example, requesting three worker nodes with default configuration can be achieved by submitting an array of three empty objects:
```"workers": [{}, {}, {}]```
*/
func (a *Client) AddCluster(params *AddClusterParams) (*AddClusterCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddClusterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addCluster",
		Method:             "POST",
		PathPattern:        "/v4/clusters/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddClusterReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddClusterCreated), nil

}

/*
AddKeyPair adds key pair for cluster
*/
func (a *Client) AddKeyPair(params *AddKeyPairParams) (*AddKeyPairOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddKeyPairParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addKeyPair",
		Method:             "POST",
		PathPattern:        "/v4/clusters/{cluster_id}/key-pairs/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddKeyPairReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddKeyPairOK), nil

}

/*
DeleteCluster deletes cluster

This operation allows to delete a cluster.

__Caution:__ Deleting a cluster causes the termination of all workloads
running on the cluster. Data stored on the worker nodes will be lost.
There is no way to undo this operation.

The response is sent as soon as the request is validated. At that point,
workloads might still be running on the cluster and may be accessible
for a little wile, until the cluster is actually deleted.

*/
func (a *Client) DeleteCluster(params *DeleteClusterParams) (*DeleteClusterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteCluster",
		Method:             "DELETE",
		PathPattern:        "/v4/clusters/{cluster_id}/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteClusterAccepted), nil

}

/*
GetCluster gets cluster details
*/
func (a *Client) GetCluster(params *GetClusterParams) (*GetClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getCluster",
		Method:             "GET",
		PathPattern:        "/v4/clusters/{cluster_id}/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterOK), nil

}

/*
GetClusters gets clusters

This operation fetches a list of clusters.
The result depends on the permissions of the user.
A normal user will get all the clusters the user has access
to, via organization membership.

A user with admin permission will receive a list of all existing
clusters.

The result array items are sparse representations of the cluster
objects.

*/
func (a *Client) GetClusters(params *GetClustersParams) (*GetClustersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClustersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusters",
		Method:             "GET",
		PathPattern:        "/v4/clusters/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClustersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClustersOK), nil

}

/*
GetInfo gets information on the installation

See https://docs.giantswarm.io/api/#operation/getInfo
*/
func (a *Client) GetInfo(params *GetInfoParams) (*GetInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInfoParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getInfo",
		Method:             "GET",
		PathPattern:        "/v4/info/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInfoReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetInfoOK), nil

}

/*
GetKeyPairs gets key pairs for cluster
*/
func (a *Client) GetKeyPairs(params *GetKeyPairsParams) (*GetKeyPairsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetKeyPairsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getKeyPairs",
		Method:             "GET",
		PathPattern:        "/v4/clusters/{cluster_id}/key-pairs/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetKeyPairsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetKeyPairsOK), nil

}

/*
GetReleases gets releases
*/
func (a *Client) GetReleases(params *GetReleasesParams) (*GetReleasesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReleasesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getReleases",
		Method:             "GET",
		PathPattern:        "/v4/releases/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetReleasesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReleasesOK), nil

}

/*
GetUserOrganizations gets organizations for user

This operation allows to fetch a list of organizations the user is a
member of. In the case of an admin user, the result includes all
existing organizations.

*/
func (a *Client) GetUserOrganizations(params *GetUserOrganizationsParams) (*GetUserOrganizationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserOrganizationsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUserOrganizations",
		Method:             "GET",
		PathPattern:        "/v4/organizations/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUserOrganizationsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUserOrganizationsOK), nil

}

/*
ModifyCluster modifies cluster
*/
func (a *Client) ModifyCluster(params *ModifyClusterParams) (*ModifyClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewModifyClusterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "modifyCluster",
		Method:             "PATCH",
		PathPattern:        "/v4/clusters/{cluster_id}/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ModifyClusterReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ModifyClusterOK), nil

}

/*
UserLogin logs in as a user

This method takes email and password of a user and returns a new session
token. The token can be found in the `data.Id` field of the response
object.

*/
func (a *Client) UserLogin(params *UserLoginParams) (*UserLoginOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserLoginParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "userLogin",
		Method:             "POST",
		PathPattern:        "/v1/user/{email}/login",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserLoginReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserLoginOK), nil

}

/*
UserLogout expires the currently used auth token
*/
func (a *Client) UserLogout(params *UserLogoutParams) (*UserLogoutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserLogoutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "userLogout",
		Method:             "POST",
		PathPattern:        "/v1/token/logout",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UserLogoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserLogoutOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
