// Code generated by go-swagger; DO NOT EDIT.

package apps

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new apps API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for apps API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateClusterApp installs an app

Install an app on a tenant cluster by posting to this endpoint.

The spec field represents the app we'll be installing, and so spec.name refers to
the name of the chart that installs this app in the catalog.

The response you get on a succesful create includes the status of the app. However
since the App is still initialising and this is an asynchronous operation, it is
likely that the fields in this status object will be all empty values.

To check on the status of your app, perform a GET to /v4/clusters/{cluster_id}/apps/,
and check the status field of the app.
###

### Example PUT request
```json
  {
    "spec": {
      "catalog": "sample-catalog",
      "name": "prometheus-chart",
      "namespace": "prometheus",
      "version": "0.2.0",
      "user_config": {
        "configmap": {
          "name": "prometheus-user-values",
          "namespace": "123ab"
        }
      }
    }
  }
```

*/
func (a *Client) CreateClusterApp(params *CreateClusterAppParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterAppOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterAppParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterApp",
		Method:             "PUT",
		PathPattern:        "/v4/clusters/{cluster_id}/apps/{app_name}/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterAppReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterAppOK), nil

}

/*
CreateClusterAppConfig creates app config

This operation allows you to create a values configmap for a specific app. The app does
not have to exist before hand.


### Example POST request
```json
  {
    "agent": {
      "key": "secret-key-here",
      "endpointHost": "saas-eu-west-1.instana.io",
      "endpointPort": "443",
    },
    "zone": {
      "name": "giantswarm-cluster"
    }
  }
```

*/
func (a *Client) CreateClusterAppConfig(params *CreateClusterAppConfigParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterAppConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterAppConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterAppConfig",
		Method:             "PUT",
		PathPattern:        "/v4/clusters/{cluster_id}/apps/{app_name}/config/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterAppConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterAppConfigOK), nil

}

/*
DeleteClusterApp deletes an app

This operation allows a user to delete an app.

*/
func (a *Client) DeleteClusterApp(params *DeleteClusterAppParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteClusterAppOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterAppParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteClusterApp",
		Method:             "DELETE",
		PathPattern:        "/v4/clusters/{cluster_id}/apps/{app_name}/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterAppReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteClusterAppOK), nil

}

/*
DeleteClusterAppConfig deletes an app config

This operation allows a user to delete an app's user config if it has been named according to the convention of {app-name}-user-values and
stored in the cluster ID namespace.

Calling this endpoint will delete the ConfigMap, but it does not remove the reference to the ConfigMap in the (spec.user_config.configmap field) from the app.

Do make sure you also update the app and remove the reference.

The preferred order is to first remove the reference to the configmap by
updating the app, and only then delete the configmap using this endpoint.

*/
func (a *Client) DeleteClusterAppConfig(params *DeleteClusterAppConfigParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteClusterAppConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterAppConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteClusterAppConfig",
		Method:             "DELETE",
		PathPattern:        "/v4/clusters/{cluster_id}/apps/{app_name}/config/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterAppConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteClusterAppConfigOK), nil

}

/*
GetAppCatalogs gets a list of app catalogs configured on your installation

Returns an array of app catalog objects, which contains further metadata,
including a URL to fetch the full index of each catalog.


### Example
```json
  [
    {
      "metadata": {
        "name": "sample-catalog",
      },

      "spec": {
        "description": "Giant Swarm's Sample Catalog with a few apps to test things out.",
        "logoURL": "https://s.giantswarm.io/app-catalog/1/images/sample-catalog.png",

        "storage": {
          "URL": "https://giantswarm.github.com/sample-catalog/",
          "type": "helm"
        },
        "title": "Sample Catalog"
      }
    }
  ]
```

*/
func (a *Client) GetAppCatalogs(params *GetAppCatalogsParams, authInfo runtime.ClientAuthInfoWriter) (*GetAppCatalogsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAppCatalogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAppCatalogs",
		Method:             "GET",
		PathPattern:        "/v4/appcatalogs/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAppCatalogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAppCatalogsOK), nil

}

/*
GetClusterAppConfig gets app config

This operation allows you to fetch the user values configmap associated
with an app.

*/
func (a *Client) GetClusterAppConfig(params *GetClusterAppConfigParams, authInfo runtime.ClientAuthInfoWriter) (*GetClusterAppConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterAppConfigParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterAppConfig",
		Method:             "GET",
		PathPattern:        "/v4/clusters/{cluster_id}/apps/{app_name}/config/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterAppConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterAppConfigOK), nil

}

/*
GetClusterApps gets cluster apps

Returns an array of apps installed on a given cluster.

### Example
```json
  [
    {
      "metadata": {
        "name": "my-awesome-prometheus",
      },

      "spec": {
        "catalog": "sample-catalog"
        "name": "prometheus-chart",
        "namespace": "giantswarm",
        "version": "0.2.0",
        "user_config": {
          "configmap": {
            "name": "prometheus-user-values",
            "namespace": "123ab"
          }
        }
      },

      "status": {
        "app_version": "1.0.0",
        "release": {
          "last_deployed": "2019-04-08T12:34:00Z",
          "status": "DEPLOYED"
        },
        "version": "0.2.0",
      }
    }
  ]
```

*/
func (a *Client) GetClusterApps(params *GetClusterAppsParams, authInfo runtime.ClientAuthInfoWriter) (*GetClusterAppsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterAppsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterApps",
		Method:             "GET",
		PathPattern:        "/v4/clusters/{cluster_id}/apps/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterAppsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterAppsOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
